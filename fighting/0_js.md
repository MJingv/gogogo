# 垃圾回收

什么数据需要回收

- 栈：当一个函数执行结束之后，JavaScript引擎会通过向下移动ESP（执行状态指针）来销毁该函数保存在栈中的执行上下文
- 堆：对象需要垃圾回收

代际假说

- 是gc的理论基础，假设
- 大部分的对象生命周期短，小部分的对象存活时间长
- v8把堆gc分成新生代（存活时间短的对象），老生代（存活时间长的对象）

gc执行流程

- 标记活动对象和非活动对象
- 回收非活动对象所占内存
- 内存整理（可选）。内存有不连续的空间，需要整理内存碎片

新生代gc

- 特点：空间小，大部分是小对象，gc频繁
- scavenger算法
    - 空间分为：对象区域+空闲区域
    - 流程
        - 标记：对对象区域里的垃圾做标记
        - 清除：垃圾回收器把存活的对象复制到空闲区域，有序排列
        - 反转：对象区域和空闲区域做反转，让这2块区域无限复制和使用
- 对象晋升
    - 2次gc还存活的对象，移到老生代处理

老生代gc

- 特点：占用空间大，存活时间长
- 标记-清除-整理
    - 标记：从根元素开始遍历，能够到达的为活动对象，不能的为垃圾
    - 清除：把垃圾直接清除
    - 整理：存活对象向一端移动，整理内存
- 增量标记
    - 拆分gc任务，穿插执行其他js任务，避免卡顿

---


js原始数据类型

- 7个:null/undefined/boolean/string/number/symbol/bigint

js引用数据类型

- 6个object:object/array/date/regexp/function/math

0.1+0.2!==0.3

- 0.1和0.2转成二进制都会无限循环，所有语言都如此，它们有double/float
- 因为浮点数限制，截断了二进制数字，出现了精度丢失s
- 最大是2^53-1,最小是-(2^53-1),超过用bigint，10n代表10倍的最大数

typeof

- 检测基本类型
- typeof null===‘object’ 这个是错误的

instanceof

- 判断是否为类的实例
- 判断引用类型，也可以判断包装object的基本类型
- reduce

```js
const list = [1, [2, [3, [4, 5]]], 6]
const helper = (list, res = []) => {
    const len = list.length
    if (!len) return
    for (let i = 0; i < len; i++) {
        if (Array.isArray(list[i])) {
            helper(list[i], res)
        } else {
            res.push(list[i])
        }
    }
    return res

}
```

- 递归
- 扩展运算符

flat数组

- list.flat(depth=Infinity)
- JSON.stringify(list).replace(/\[|\]/g,'').split(',')

数据存储

- 基本类型 栈
- 引用类型 堆（复制引用地址）
- 闭包 堆

v8垃圾回收gc

- garbage collection 一种自动内存管理机制。用于自动检测回收不再使用的对象。
- 方法：标记清除法、引用计数法（x循环引用）、分代回收法
- js单线程，垃圾回收内存小，64位1.4g，32位0.7g

- 标记清除法：
    - 标记：根对象开始，active的对象标记
    - 清除：遍历清除没有标记的对象
    - 压缩：碎片压缩堆内存，创造更大的连续空间
- 新生代+老生代
- 新生代（标记-复制法）
    - 2部分组成：from忙+to闲
    - from忙的scavenger算法顺序复制到to
    - 多次copy还活晋升到老生代
    - 只能用一半内存，性能高，不产生内存碎片，空间利用率低
- 晋升（从新到老）：scavenge1次，to>25%，多次在新生代里
- 老生代
    - 标记清除：遍历 使用中+强引用 做标记，删除无标记的。整理内存碎片，向一边靠拢
    - 增量标记：分解多部分，每次执行1小部分

可能导致内存泄漏的操作

- 事件监听
    - 及时解除事件监听器，removeEventListener等方法
- 闭包
    - 及时解除闭包，释放引用
- 定时器
    - 及时清除定时器
- 循环引用
    - 避免循环引用，合理规划对象的生命周期和引用关系
- 大量缓存数据
    - 及时清除缓存数据

v8执行js过程

- 词法分析和语法分析生成AST树
- AST转换成生成字节码（节约内存）
- 解释器执行字节码，hotspot进行编译，生成机器码
- 解释器和编译器结合叫JIT（即时编译）

event loop

- macrotask宏任务：网络请求/定时器/渲染页面/用户交互/io/js脚本执行
- microtask微任务：process.nextticket/promise/mutationObserver

闭包

- 红宝书定义：有权访问另一个函数作用域中变量的函数
- es5有2个作用于：函数作用域+全局作用域
- 表现形式：返回函数，参数函数。用回调就是闭包
  闭包作用：
- 回调函数
- 私有变量
- 封装数据，独立作用域
- 保持状态，不需要全局变量

es module vs commonjs vs amd/cmd/umd
不同的模块化规范，管理模块的导入和导出

commonjs

- require+exports
- 动态，导入和导出为动态。运行时按顺序加载和执行，同步加载
- 引用类型：导入对象的值，多次导入多个实例，不会影响原对象
  -CommonJS 更适用于服务器端开发和构建工具
  es module

- import+export
- 静态，导入和导出静态。编译时确定依赖。导入支持.then动态导入
- 引用类型：export具名导出是引用地址，会影响原对象。export默认导出是复制值，不会影响。
- ESM 的静态特性使得工具可以进行静态分析和优化，例如进行 Tree Shaking（摇树优化）来消除未使用的代码，减小打包体积。
- ESM 更适用于现代浏览器环境和前端开发。浏览器逐步兼容
