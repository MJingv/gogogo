v8是google开发的js引擎

解释器vs编译器？

- 计算机只能识别二进制指令，执行高级语言2个方案：编译和解释
- 解释执行，解释器执行中间码¬，启动快
- 编译执行，编译器保存机器码，运行快
- v8用jit同时解释+编译

v8执行js主要流程

- 初始化环境
- 解析源代码，词法+语法分析生成ast和作用域
- 根据以上生成字节码
- 解释执行字节码
- 监听热点代码
- 优化热点代码为机器码
- 反优化生成机器码

如何提升对象属性的访问速度？

- 对象由属性+值组成。使用字典读取效率低
- v8对象2个隐藏属性：排序属性和常规属性
    - 排序属性，element属性存element对象。eg.数组`arr[0]`
    - 常规属性,properties按创建顺序保存，eg.obj.foo
- 对象属性少，直接存对象本身
- 对象属性多&操作多，非线性字典结构，降低查询速度，增加修改速度

v8函数

- 函数声明vs函数表达式
- 变量提升：
    - 定义：编译阶段，把所有变量提升到作用域的过程叫做变量提升
    - 普通变量，提升=undefined（表达式），函数表达式=undefined
    - 函数声明，提升为函数对象（语句）

继承

- 概念，继承就是一个对象可以访问另一个对象的属性和方法
- 继承实现方式：基于类，基于原型
- 对象有__proto__,函数有.prototype，对象的__proto__等于(指向)它的构造函数的prototype。如果一个obj没有该属性和方法，会沿原型链向上查，直到Object.prototype

如何查找变量，作用域

- 概念：存变量和函数的地方
- 分类：全局作用域、函数作用域、块级作用域
- js是词法作用域

类型转换

- v8有toPrimitive方法,将a和b转为原生数据类型
    - valueof是对象则返回
    - 用tostring转
    - 都没有返回基本类型，触发typeerror错误

运行时

- v8初始化存储空间：栈和堆
- 初始化全局context和全局作用域
- 初始化事件循环

cpu如何执行机器码

- c编译器将c转为机器码
- 二进制进内存，cpu按照指令一行行执行（取指令、分析指令、执行指令，三步一个cpu时钟周期）
- cpu对数据要读写，引入寄存器，中间数据放寄存器（加载指令、存储指令、更新指令）

v8为什么引入字节码

- 早期
    - 直接生成二进制
    - 基线编译器+优化编译器
    - 过程
        - js转成ast
        - 基线编译器转成无优化的机器码
        - 执行机器码，多次重复执行的hot，优化
        - 没有优化成功的，反优化
- 后期
    - 生成字节码
    - Ignition
    - 3个优势
        - 启动时间短，生成字节码快
        - 空间小，字节码占内存少，缓存
        - 架构清晰，v8移植到不同平台更容易

如何执行字节码



